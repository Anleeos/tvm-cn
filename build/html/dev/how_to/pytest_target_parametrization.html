
<!DOCTYPE html>

<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Python Target Parametrization &#8212; tvm-cn 1.0.0 文档</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/translations.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="Design and Architecture" href="../../arch/index.html" />
    <link rel="prev" title="Bring Your Own Codegen To TVM" href="relay_bring_your_own_codegen.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="python-target-parametrization">
<h1>Python Target Parametrization<a class="headerlink" href="#python-target-parametrization" title="Permalink to this heading">¶</a></h1>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>For any supported runtime, TVM should produce numerically
correct results.  Therefore, when writing unit tests that validate
the numeric output, these unit tests should be run on all supported
runtimes.  Since this is a very common use case, TVM has helper
functions to parametrize unit tests such that they will run on all
targets that are enabled and have a compatible device.</p>
<p>A single python function in the test suite can expand to several
parameterized unit tests, each of which tests a single target device.
In order for a test to be run, all of the following must be true.</p>
<ul class="simple">
<li><p>The test exists in a file or directory that has been passed to
<cite>pytest</cite>.</p></li>
<li><p>The pytest marks applied to the function, either explicitly or
through target parametrization, must be compatible with the
expression passed to pytest’s <cite>-m</cite> argument.</p></li>
<li><p>For parametrized tests using the <cite>target</cite> fixture, the target must
appear in the environment variable <cite>TVM_TEST_TARGETS</cite>.</p></li>
<li><p>For parametrized tests using the <cite>target</cite> fixture, the build
configuration in <cite>config.cmake</cite> must enable the corresponding
runtime.</p></li>
</ul>
</section>
<section id="unit-test-file-contents">
<h2>Unit-Test File Contents<a class="headerlink" href="#unit-test-file-contents" title="Permalink to this heading">¶</a></h2>
<p>The recommended method to run a test on multiple targets is by
parametrizing the test.  This can be done explicitly for a fixed list
of targets by decorating with
<code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.parametrize_targets('target_1',</span> <span class="pre">'target_2',</span> <span class="pre">...)</span></code>, and
accepting <code class="docutils literal notranslate"><span class="pre">target</span></code> or <code class="docutils literal notranslate"><span class="pre">dev</span></code> as function arguments.  The function
will be run once for each target listed, and the success/failure of
each target is reported separately.  If a target cannot be run because
it is disabled in the <cite>config.cmake</cite>, or because no appropriate
hardware is present, then that target will be reported as skipped.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Explicit listing of targets to use.</span>
<span class="nd">@tvm</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">parametrize_target</span><span class="p">(</span><span class="s1">&#39;llvm&#39;</span><span class="p">,</span> <span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_function</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dev</span><span class="p">):</span>
    <span class="c1"># Test code goes here</span>
</pre></div>
</div>
<p>For tests that should run correctly on all targets, the decorator can
be omitted.  Any test that accepts a <code class="docutils literal notranslate"><span class="pre">target</span></code> or <code class="docutils literal notranslate"><span class="pre">dev</span></code> argument
will automatically be parametrized over all targets specified in
<code class="docutils literal notranslate"><span class="pre">TVM_TEST_TARGETS</span></code>.  The parametrization provides the same
pass/fail/skipped report for each target, while allowing the test
suite to be easily extended to cover additional targets.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implicitly parametrized to run on all targets</span>
<span class="c1"># in environment variable TVM_TEST_TARGETS</span>
<span class="k">def</span> <span class="nf">test_function</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dev</span><span class="p">):</span>
    <span class="c1"># Test code goes here</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.parametrize_targets</span></code> can also be used as a bare
decorator to explicitly draw attention to the parametrization, but has
no additional effect.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Explicitly parametrized to run on all targets</span>
<span class="c1"># in environment variable TVM_TEST_TARGETS</span>
<span class="nd">@tvm</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">parametrize_targets</span>
<span class="k">def</span> <span class="nf">test_function</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dev</span><span class="p">):</span>
    <span class="c1"># Test code goes here</span>
</pre></div>
</div>
<p>Specific targets can be excluded or marked as expected to fail using
the <code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.exclude_targets</span></code> or
<code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.known_failing_targets</span></code> decorators.  For more
information on their intended use cases, please see their docstrings.</p>
<p>In some cases it may be necessary to parametrize across multiple
parameters.  For instance, there may be target-specific
implementations that should be tested, where some targets have more
than one implementation.  These can be done by explicitly
parametrizing over tuples of arguments, such as shown below.  In these
cases, only the explicitly listed targets will run, but they will
still have the appropriate <code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.requires_RUNTIME</span></code> mark
applied to them.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="s1">&#39;target,impl&#39;</span><span class="p">,</span> <span class="p">[</span>
     <span class="p">(</span><span class="s1">&#39;llvm&#39;</span><span class="p">,</span> <span class="n">cpu_implementation</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">gpu_implementation_small_batch</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">gpu_implementation_large_batch</span><span class="p">),</span>
 <span class="p">])</span>
 <span class="k">def</span> <span class="nf">test_function</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">impl</span><span class="p">):</span>
     <span class="c1"># Test code goes here</span>
</pre></div>
</div>
<p>The parametrization functionality is implemented
on top of pytest marks.  Each test function can
be decorated with <a class="reference external" href="pytest-marks">pytest marks</a>
to include metadata.  The most frequently applied
marks are as follows.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;pytest.mark.gpu</span></code> - Tags a function as using GPU
capabilities. This has no effect on its own, but can be paired with
command-line arguments <code class="docutils literal notranslate"><span class="pre">-m</span> <span class="pre">gpu</span></code> or <code class="docutils literal notranslate"><span class="pre">-m</span> <span class="pre">'not</span> <span class="pre">gpu'</span></code> to restrict
which tests pytest will execute.  This should not be called on its
own, but is part of other marks used in unit-tests.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.uses_gpu</span></code> - Applies <code class="docutils literal notranslate"><span class="pre">&#64;pytest.mark.gpu</span></code>.  This
should be used to mark unit tests that may use the GPU, if one is
present.  This decorator is only needed for tests that explicitly
loop over <code class="docutils literal notranslate"><span class="pre">tvm.testing.enabled_targets()</span></code>, but that is no longer
the preferred style of writing unit tests (see below).  When using
<code class="docutils literal notranslate"><span class="pre">tvm.testing.parametrize_targets()</span></code>, this decorator is implicit
for GPU targets, and does not need to be explicitly applied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.requires_gpu</span></code> - Applies <code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.uses_gpu</span></code>,
and additionally marks that the test should be skipped
(<code class="docutils literal notranslate"><span class="pre">&#64;pytest.mark.skipif</span></code>) entirely if no GPU is present.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;tvfm.testing.requires_RUNTIME</span></code> - Several decorators
(e.g. <code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.requires_cuda</span></code>), each of which skips a test if
the specified runtime cannot be used. A runtime cannot be used if it
is disabled in the <code class="docutils literal notranslate"><span class="pre">config.cmake</span></code>, or if a compatible device is
not present. For runtimes that use the GPU, this includes
<code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.requires_gpu</span></code>.</p></li>
</ul>
<p>When using parametrized targets, each test run is decorated with the
<code class="docutils literal notranslate"><span class="pre">&#64;tvm.testing.requires_RUNTIME</span></code> that corresponds to the target
being used.  As a result, if a target is disabled in <code class="docutils literal notranslate"><span class="pre">config.cmake</span></code>
or does not have appropriate hardware to run, it will be explicitly
listed as skipped.</p>
<p>There also exists a <code class="docutils literal notranslate"><span class="pre">tvm.testing.enabled_targets()</span></code> that returns
all targets that are enabled and runnable on the current machine,
based on the environment variable <code class="docutils literal notranslate"><span class="pre">TVM_TEST_TARGETS</span></code>, the build
configuration, and the physical hardware present.  Most current tests
explicitly loop over the targets returned from <code class="docutils literal notranslate"><span class="pre">enabled_targets()</span></code>,
but it should not be used for new tests.  The pytest output for this
style silently skips runtimes that are disabled in <code class="docutils literal notranslate"><span class="pre">config.cmake</span></code>,
or do not have a device on which they can run.  In addition, the test
halts on the first target to fail, which is ambiguous as to whether
the error occurs on a particular target, or on every target.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Old style, do not use.</span>
<span class="k">def</span> <span class="nf">test_function</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">target</span><span class="p">,</span><span class="n">dev</span> <span class="ow">in</span> <span class="n">tvm</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">enabled_targets</span><span class="p">():</span>
        <span class="c1"># Test code goes here</span>
</pre></div>
</div>
</section>
<section id="running-locally">
<h2>Running locally<a class="headerlink" href="#running-locally" title="Permalink to this heading">¶</a></h2>
<p>To run the python unit-tests locally, use the command <code class="docutils literal notranslate"><span class="pre">pytest</span></code> in
the <code class="docutils literal notranslate"><span class="pre">${TVM_HOME}</span></code> directory.</p>
<ul>
<li><dl>
<dt>Environment variables</dt><dd><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">TVM_TEST_TARGETS</span></code> should be a semicolon-separated list of
targets to run. If unset, will default to the targets defined in
<code class="docutils literal notranslate"><span class="pre">tvm.testing.DEFAULT_TEST_TARGETS</span></code>.</p>
<p>Note: If <code class="docutils literal notranslate"><span class="pre">TVM_TEST_TARGETS</span></code> does not contain any targets that
are both enabled, and have an accessible device of that type,
then the tests will fall back to running on the <code class="docutils literal notranslate"><span class="pre">llvm</span></code> target
only.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">TVM_LIBRARY_PATH</span></code> should be a path to the <code class="docutils literal notranslate"><span class="pre">libtvm.so</span></code>
library. This can be used, for example, to run tests using a
debug build. If unset, will search for <code class="docutils literal notranslate"><span class="pre">libtvm.so</span></code> relative to
the TVM source directory.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Command-line arguments</p>
<blockquote>
<div><ul>
<li><p>Passing a path to a folder or file will run only the unit tests
in that folder or file. This can be useful, for example, to
avoid running tests located in <code class="docutils literal notranslate"><span class="pre">tests/python/frontend</span></code> on a
system without a specific frontend installed.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">-m</span></code> argument only runs unit tests that are tagged with a
specific pytest marker. The most frequent usage is to use <code class="docutils literal notranslate"><span class="pre">m</span>
<span class="pre">gpu</span></code> to run only tests that are marked with
<code class="docutils literal notranslate"><span class="pre">&#64;pytest.mark.gpu</span></code> and use a GPU to run. It can also be used
to run only tests that do not use a GPU, by passing <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">'not</span>
<span class="pre">gpu'</span></code>.</p>
<p>Note: This filtering takes place after the selection of targets
based on the <code class="docutils literal notranslate"><span class="pre">TVM_TEST_TARGETS</span></code> environment variable.  Even if
<code class="docutils literal notranslate"><span class="pre">-m</span> <span class="pre">gpu</span></code> is specified, if <code class="docutils literal notranslate"><span class="pre">TVM_TEST_TARGETS</span></code> does not
contain GPU targets, no GPU tests will be run.</p>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
<section id="running-in-local-docker-container">
<h2>Running in local docker container<a class="headerlink" href="#running-in-local-docker-container" title="Permalink to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">docker/bash.sh</span></code> script can be used to run unit tests inside the
same docker image as is used by the CI.  The first argument should
specify which docker image to run (e.g. <code class="docutils literal notranslate"><span class="pre">docker/bash.sh</span> <span class="pre">ci_gpu</span></code>).
Allowed image names are defined at the top of the Jenkinsfile located
in the TVM source directory, and map to images at <a class="reference external" href="https://hub.docker.com/u/tlcpack">tlcpack</a>.</p>
<p>If no additional arguments are given, the docker image will be loaded
with an interactive bash session.  If a script is passed as an
optional argument (e.g. <code class="docutils literal notranslate"><span class="pre">docker/bash.sh</span> <span class="pre">ci_gpu</span> <span class="pre">tests/scripts/task_python_unittest.sh</span></code>), then that script will be
executed inside the docker image.</p>
<p>Note: The docker images contain all system dependencies, but do not
include the <code class="docutils literal notranslate"><span class="pre">build/config.cmake</span></code> configuration file for those
systems.  The TVM source directory is used as the home directory of
the docker image, and so this will default to using the same
config/build directories as the local config.  One solution is to
maintain separate <code class="docutils literal notranslate"><span class="pre">build_local</span></code> and <code class="docutils literal notranslate"><span class="pre">build_docker</span></code> directories,
and make a symlink from <code class="docutils literal notranslate"><span class="pre">build</span></code> to the appropriate folder when
entering/exiting docker.</p>
</section>
<section id="running-in-ci">
<h2>Running in CI<a class="headerlink" href="#running-in-ci" title="Permalink to this heading">¶</a></h2>
<p>Everything in the CI starts from the task definitions present in the
Jenkinsfile.  This includes defining which docker image gets used,
what the compile-time configuration is, and which tests are included
in which stages.</p>
<ul>
<li><p>Docker images</p>
<p>Each task of the Jenkinsfile (e.g. ‘BUILD: CPU’) makes calls to
<code class="docutils literal notranslate"><span class="pre">docker/bash.sh</span></code>.  The argument following the call to
docker/bash.sh defines the docker image in CI, just as it does
locally.</p>
</li>
<li><p>Compile-time configuration</p>
<p>The docker image does not have the <code class="docutils literal notranslate"><span class="pre">config.cmake</span></code> file built into
it, so this is the first step in each of the <code class="docutils literal notranslate"><span class="pre">BUILD</span></code> tasks.  This
is done using the <code class="docutils literal notranslate"><span class="pre">tests/scripts/task_config_build_*.sh</span></code> scripts.
Which script is used depends on the build being tested, and is
specified in the Jenkinsfile.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">BUILD</span></code> task concludes by packing a library for use in later
tests.</p>
</li>
<li><p>Which tests run</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Unit</span> <span class="pre">Test</span></code> and <code class="docutils literal notranslate"><span class="pre">Integration</span> <span class="pre">Test</span></code> stages of the Jenkinsfile
determine how <code class="docutils literal notranslate"><span class="pre">pytest</span></code> is called.  Each task starts by unpacking a
compiled library that was previous compiled in the <code class="docutils literal notranslate"><span class="pre">BUILD</span></code> stage,
then runs a test script
(e.g. <code class="docutils literal notranslate"><span class="pre">tests/script/task_python_unittest.sh</span></code>).  These scripts set
the files/folders and command-line options that are passed to
<code class="docutils literal notranslate"><span class="pre">pytest</span></code>.</p>
<p>Several of these scripts include the <code class="docutils literal notranslate"><span class="pre">-m</span> <span class="pre">gpu</span></code> option, which
restricts the tests to only run tests that include the
<code class="docutils literal notranslate"><span class="pre">&#64;pytest.mark.gpu</span></code> mark.</p>
</li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">tvm-cn</a></h1>








<h3>导航</h3>
<p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">安装 TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributor Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../how_to/index.html">How To Guides</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Developer Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="how_to.html">Developer How-To Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Architecture Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">Design and Architecture</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Topic Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../topic/microtvm/index.html">microTVM: TVM on bare-metal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../topic/vta/index.html">VTA: Versatile Tensor Accelerator</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="how_to.html">Developer How-To Guide</a><ul>
      <li>Previous: <a href="relay_bring_your_own_codegen.html" title="上一章">Bring Your Own Codegen To TVM</a></li>
      <li>Next: <a href="../../arch/index.html" title="下一章">Design and Architecture</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, HyperAI.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/dev/how_to/pytest_target_parametrization.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>