
<!DOCTYPE html>

<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Relay Operator Strategy &#8212; tvm-cn 1.0.0 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="Convert Layout Pass" href="convert_layout.html" />
    <link rel="prev" title="Introduction to Relay IR" href="relay_intro.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="relay-operator-strategy">
<span id="relay-op-strategy"></span><h1>Relay Operator Strategy<a class="headerlink" href="#relay-operator-strategy" title="Permalink to this heading">¶</a></h1>
<p>In order to lower Relay operators to the implementations defined in TOPI
library, a compute and schedule function need to be registered to each Relay
operator.  However, compute and schedule functions are usually specialized for
each target, and further, even for the same target, we may have multiple
algorithms and implementations available. To deal with the complexity, we
introduce operator strategy to allow developers to define a flexible lowering
strategy for each operator and target.</p>
<section id="operator-strategy-design">
<h2>Operator Strategy Design<a class="headerlink" href="#operator-strategy-design" title="Permalink to this heading">¶</a></h2>
<p>The basic element in operator strategy is an <code class="docutils literal notranslate"><span class="pre">OpImplementation</span></code>. It includes
the a pair of compute and schedule function, the name of the implementation,
and a priority level (the use of priority level is explained in
<a class="reference internal" href="#select-implementation-from-op-strategy">Select Implementation from Op Strategy</a>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">OpStrategy</span></code> includes a list of <code class="docutils literal notranslate"><span class="pre">OpSpecialization</span></code>. Each <code class="docutils literal notranslate"><span class="pre">OpSpecialization</span></code>
contains a list of <code class="docutils literal notranslate"><span class="pre">OpImplementation</span></code> associated with a <code class="docutils literal notranslate"><span class="pre">SpecializedCondition</span></code>
(see definition in <code class="docutils literal notranslate"><span class="pre">include/tvm/te/schedule.h</span></code>).  The <code class="docutils literal notranslate"><span class="pre">SpecializedCondition</span></code>
can be null, indicating the implementations are generally applicable;
otherwise, the implementations are only considered when the specialized
condition is satisfied. <code class="docutils literal notranslate"><span class="pre">SpecializedCondition</span></code> consists of a list
of clauses defined in Tensor Expression in conjunctive normal form (CNF) and
only supports conditions on tensor shapes.</p>
<p>Last, a strategy function, or <code class="docutils literal notranslate"><span class="pre">FTVMStrategy</span></code>, determines which pair(s) of
compute and schedule functions should be used given a workload, and needs to be
registered to each Relay operator.  <code class="docutils literal notranslate"><span class="pre">FTVMStrategy</span></code> is a generic function (see
<code class="docutils literal notranslate"><span class="pre">include/tvm/target/generic_func.h</span></code>), that can be overwritten for each
target. The function signature is</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OpStrategy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Attrs</span><span class="o">&amp;</span><span class="w"> </span><span class="n">attrs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">out_type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Target</span><span class="o">&amp;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>that the function returns an <code class="docutils literal notranslate"><span class="pre">OpStrategy</span></code> given the op attributes, input
tensors, output types, and target to compile to.</p>
</section>
<section id="write-a-strategy-function">
<h2>Write A Strategy Function<a class="headerlink" href="#write-a-strategy-function" title="Permalink to this heading">¶</a></h2>
<p>We recommend developers to write strategy function in Python as
most TOPI compute and schedule functions are written in Python.
In python, we provide <code class="docutils literal notranslate"><span class="pre">OpStrategy</span></code> class in <code class="docutils literal notranslate"><span class="pre">pyton/tvm/relay/op/op.py</span></code>.
It only has one API, which is to add an implementation to the strategy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_implementation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compute</span><span class="p">,</span> <span class="n">schedule</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">plevel</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>We now take <code class="docutils literal notranslate"><span class="pre">topk</span></code> as an example to explain how to write the
<code class="docutils literal notranslate"><span class="pre">FTVMStrategy</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># add to python/tvm/relay/op/strategy/generic.py</span>
<span class="nd">@override_native_generic_func</span><span class="p">(</span><span class="s2">&quot;topk_strategy&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">topk_strategy</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">out_type</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">strategy</span> <span class="o">=</span> <span class="n">_op</span><span class="o">.</span><span class="n">OpStrategy</span><span class="p">()</span>
    <span class="n">strategy</span><span class="o">.</span><span class="n">add_implementation</span><span class="p">(</span>
        <span class="n">wrap_compute_topk</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">topk</span><span class="p">),</span>
        <span class="n">wrap_topi_schedule</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">generic</span><span class="o">.</span><span class="n">schedule_topk</span><span class="p">),</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;topk.generic&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">strategy</span>

<span class="c1"># add to each target file in python/tvm/relay/op/strategy, e.g., x86.py, cuda.py, etc.</span>
<span class="nd">@topk_strategy</span><span class="o">.</span><span class="n">register</span><span class="p">([</span><span class="s2">&quot;cuda&quot;</span><span class="p">,</span> <span class="s2">&quot;gpu&quot;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">topk_strategy_cuda</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">out_type</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">strategy</span> <span class="o">=</span> <span class="n">_op</span><span class="o">.</span><span class="n">OpStrategy</span><span class="p">()</span>
    <span class="n">strategy</span><span class="o">.</span><span class="n">add_implementation</span><span class="p">(</span>
        <span class="n">wrap_compute_my_new_op</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">topk</span><span class="p">),</span>
        <span class="n">wrap_topi_schedule</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">schedule_topk</span><span class="p">),</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;topk.cuda&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">strategy</span>
</pre></div>
</div>
<p>In this example, we use <code class="docutils literal notranslate"><span class="pre">topi.cuda.topk</span></code> and <code class="docutils literal notranslate"><span class="pre">topi.cuda.schedule_topk</span></code>
as the compute and schedule function for CUDA or GPU target, while use TOPI
generic compute and schedule for the rest of targets.
Note that we use two wrapper functions that wrap the topi
compute and schedule to conform with the required function signature (
see <code class="docutils literal notranslate"><span class="pre">FTVMCompute</span></code> and <code class="docutils literal notranslate"><span class="pre">FTVMSchedule</span></code> in <code class="docutils literal notranslate"><span class="pre">include/tvm/relay/op_attr_types.h</span></code>).
Usually we need to write a customized compute wrapper function for each operator
to get different fields from op attributes.</p>
<p>The example above shows a very basic strategy function that only
adds one implementation in the strategy. But for many complicated operators,
we may need to add multiple implementations that use different algorithms.
For example, we can use both direct and winograd algorithm to
compute a conv2d op. In order to achieve this, we can write the strategy function
as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">strategy</span><span class="o">.</span><span class="n">add_implementation</span><span class="p">(</span>
    <span class="n">wrap_compute_conv2d</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">conv2d_nchw</span><span class="p">),</span>
    <span class="n">wrap_topi_schedule</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">schedule_conv2d_nchw</span><span class="p">),</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;conv2d_nchw.cuda&quot;</span><span class="p">,</span>
    <span class="n">plevel</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="k">if</span> <span class="n">winograd_condition</span><span class="p">:</span>
    <span class="n">strategy</span><span class="o">.</span><span class="n">add_implementation</span><span class="p">(</span>
        <span class="n">wrap_compute_conv2d</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">conv2d_nchw_winograd</span><span class="p">),</span>
        <span class="n">wrap_topi_schedule</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">schedule_conv2d_nchw_winograd</span><span class="p">),</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;conv2d_nchw_winograd.cuda&quot;</span><span class="p">,</span>
        <span class="n">plevel</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, we add two implementations to the conv2d strategy where
winograd algorithm is only added when <code class="docutils literal notranslate"><span class="pre">winograd_condition</span></code> is true.
The implementation <code class="docutils literal notranslate"><span class="pre">&quot;conv2d_nchw_winograd.cuda&quot;</span></code> will be used to compile
conv2d when <code class="docutils literal notranslate"><span class="pre">winograd_condition</span></code> is true as it has higher
priority level (this could be changed if certain implementation is an AutoTVM
template. See <a class="reference internal" href="#select-implementation-from-op-strategy">Select Implementation from Op Strategy</a> for more
details). Otherwise, <code class="docutils literal notranslate"><span class="pre">&quot;conv2d_nchw.cuda&quot;</span></code> is used.</p>
<p>We can extend the example above to third party library implementation. For
example, we can add the implementation that invokes kernel in the cblas
library when cblas is included in the target.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="s2">&quot;cblas&quot;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">libs</span><span class="p">:</span>
    <span class="n">strategy</span><span class="o">.</span><span class="n">add_implementation</span><span class="p">(</span>
        <span class="n">wrap_compute_dense</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">x86</span><span class="o">.</span><span class="n">dense_cblas</span><span class="p">),</span>
        <span class="n">wrap_topi_schedule</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">x86</span><span class="o">.</span><span class="n">schedule_dense_cblas</span><span class="p">),</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dense_cblas.x86&quot;</span><span class="p">,</span>
        <span class="n">plevel</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>Further, we can add implementation specialized for a certain range of shapes.
The code below shows an example of dense strategy that adds an implementation
that is specialized for <code class="docutils literal notranslate"><span class="pre">m</span></code> greater than 16. The main difference between
hardcode python condition like examples above and specialized condition is that
it allows TVM to generate multiple kernels when the input tensors have symbolic
shapes. The compile engine will generate a dispatch function that invokes the
specialized kernel when the corresponding condition is met; otherwise,
invoke the kernel that has no associated specialized condition (<code class="docutils literal notranslate"><span class="pre">dense_common</span></code>
in this example). This part is still work in progress. More details will be
provided after it is done.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dense_strategy</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">out_type</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">strategy</span> <span class="o">=</span> <span class="n">_op</span><span class="o">.</span><span class="n">OpStrategy</span><span class="p">()</span>
    <span class="n">strategy</span><span class="o">.</span><span class="n">add_implementation</span><span class="p">(</span>
        <span class="n">wrap_compute_dense</span><span class="p">(</span><span class="n">dense_compute1</span><span class="p">),</span>
        <span class="n">wrap_topi_schedule</span><span class="p">(</span><span class="n">dense_schedule1</span><span class="p">),</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dense_common&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">tvm</span><span class="o">.</span><span class="n">te</span><span class="o">.</span><span class="n">SpecializedCondition</span><span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">):</span>
        <span class="n">strategy</span><span class="o">.</span><span class="n">add_implementation</span><span class="p">(</span>
            <span class="n">wrap_compute_dense</span><span class="p">(</span><span class="n">dense_compute2</span><span class="p">),</span>
            <span class="n">wrap_topi_schedule</span><span class="p">(</span><span class="n">dense_schedule2</span><span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dense_for_large_m&quot;</span><span class="p">,</span>
            <span class="n">plevel</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">strategy</span>
</pre></div>
</div>
</section>
<section id="register-strategy-function-to-an-operator">
<h2>Register Strategy Function to An Operator<a class="headerlink" href="#register-strategy-function-to-an-operator" title="Permalink to this heading">¶</a></h2>
<p>After we define the strategy function for an operator, we can now
register the strategy function to this operator with</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">register_strategy</span><span class="p">(</span><span class="s2">&quot;topk&quot;</span><span class="p">,</span> <span class="n">strategy</span><span class="o">.</span><span class="n">topk_strategy</span><span class="p">)</span>
</pre></div>
</div>
<p>However, it takes much effort to write a strategy function for an operator.
Therefore, we provide two other methods for simpler operators.</p>
<p>First, for operators that have injective, broadcast, or reduction pattern, we
can call <code class="docutils literal notranslate"><span class="pre">register_injective_schedule</span></code>, <code class="docutils literal notranslate"><span class="pre">register_broadcast_schedule</span></code>, and
<code class="docutils literal notranslate"><span class="pre">register_reduce_schedule</span></code> repsectively. The schedule function for these
patterns are already registered by each target and can be applied to these
operators. We assume the compute function should be the same across all targets,
and <code class="docutils literal notranslate"><span class="pre">FTVMCompute</span></code> needs to be registered to the op before invoking register
schedule.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">register_broadcast_schedule</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Second, for operators that doesn’t have these common patterns mentioned before,
but also have the same compute function for all targets, we can use
<code class="docutils literal notranslate"><span class="pre">register_schedule</span></code> API. It is easier to write <code class="docutils literal notranslate"><span class="pre">FTVMSchedule</span></code> function
as we only need to provide which schedule function to use. The following
code snippet shows <code class="docutils literal notranslate"><span class="pre">FTVMSchedule</span></code> function for pooling.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># add to python/tvm/relay/op/strategy/generic.py</span>
<span class="nd">@generic_func</span>
<span class="k">def</span> <span class="nf">schedule_pool</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">outs</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">topi</span><span class="o">.</span><span class="n">generic</span><span class="o">.</span><span class="n">schedule_pool</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">layout</span><span class="p">)</span>

<span class="c1"># add to each target file in python/tvm/relay/op/strategy, e.g., x86.py, cuda.py, etc.</span>
<span class="nd">@schedule_pool</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">schedule_pool_cpu</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">outs</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>After we created the <code class="docutils literal notranslate"><span class="pre">FTVMSchedule</span></code> for an operator, we can
register the strategy using <code class="docutils literal notranslate"><span class="pre">register_schedule</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">register_schedule</span><span class="p">(</span><span class="s2">&quot;nn.max_pool2d&quot;</span><span class="p">,</span> <span class="n">strategy</span><span class="o">.</span><span class="n">schedule_pool</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="register-strategies-for-a-new-target">
<h2>Register Strategies for A New Target<a class="headerlink" href="#register-strategies-for-a-new-target" title="Permalink to this heading">¶</a></h2>
<p>There are two ways to register strategies for a new target. The more
straightforward one is adding a new target file in the directory
<code class="docutils literal notranslate"><span class="pre">python/tvm/relay/op/strategy</span></code>. You only need to customize the strategy for
ops that have been implemented for this new target and reuse the generic
strategies for the rest.</p>
<p>Alternatively, you can also register the strategy for the new target outside the
TVM python library. The following code snippet shows an example how to do
so. You can find more examples in <code class="docutils literal notranslate"><span class="pre">vta/python/vta/top/op.py</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@relay</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">conv2d_strategy</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;mytarget&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">conv2d_strategy_mytarget</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">out_type</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="select-implementation-from-op-strategy">
<h2>Select Implementation from Op Strategy<a class="headerlink" href="#select-implementation-from-op-strategy" title="Permalink to this heading">¶</a></h2>
<p>During the compilation, Relay compile engine needs to determine which
implementation to use for an operator when there are multiple. The selection
policy works as follows.</p>
<p>When the input tensors to an operator or a fused op all have constant shapes,
the compile engine first finds the best implementation based on AutoTVM tuning
logs. If there is no implementation that is an AutoTVM template or all AutoTVM
templates have fallback configs, the implementation with highest priority level
will then be chosen. Implementations with same priority level in this case leads
to an undefined behavior, and any of them might be selected.</p>
<p>The selection policy for ops with symbolic input shapes is still work in
progress. Currently, if any input tensor has a symbolic shape, only the
implementation with highest priority level will be used for this operator. This
will be updated after the implementation finishes.</p>
<p>For debug purpose, you can add the following lines before you compile the Relay
model to learn which implementation is used for each operator.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;te_compiler&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;te_compiler&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">))</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">tvm-cn</a></h1>








<h3>导航</h3>
<p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">安装 TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contributor Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../how_to/index.html">How To Guides</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev/tutorial/index.html">Developer Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/how_to/how_to.html">Developer How-To Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Architecture Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Design and Architecture</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Topic Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topic/microtvm/index.html">microTVM: TVM on bare-metal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic/vta/index.html">VTA: Versatile Tensor Accelerator</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Design and Architecture</a><ul>
      <li>Previous: <a href="relay_intro.html" title="上一章">Introduction to Relay IR</a></li>
      <li>Next: <a href="convert_layout.html" title="下一章">Convert Layout Pass</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, HyperAI.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/arch/relay_op_strategy.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>