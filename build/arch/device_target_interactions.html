
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Device/Target Interactions &#8212; tvm-cn 1.0.0 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="Pass Infrastructure" href="pass_infra.html" />
    <link rel="prev" title="Introduction to Module Serialization" href="introduction_to_module_serialization.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="device-target-interactions">
<span id="tvm-target-specific-overview"></span><h1>Device/Target Interactions<a class="headerlink" href="#device-target-interactions" title="永久链接至标题">¶</a></h1>
<p>This documented is intended for developers interested in understanding
how the TVM framework interacts with specific device APIs, or who
may want to implement support for a new API or new hardware.</p>
<p>There are three main aspects that must be implemented for any new
runtime environment.</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="#tvm-target-specific-device-api"><span class="std std-ref">DeviceAPI</span></a> class gives a
handle to a specific device, and the API used to interact with it.
It defines a common interface for querying device parameters
(e.g. memory available, number of threads, etc.) and for performing
simple actions (e.g. copying memory from the host, or between
buffers on the device).</p></li>
<li><p>The <a class="reference internal" href="#tvm-target-specific-target"><span class="std std-ref">Target</span></a> class contains a
description of the device on which a function will run.  It is
exposed both to the target code generators and to the optimization
passes.</p></li>
<li><p>The <a class="reference internal" href="#tvm-target-specific-codegen"><span class="std std-ref">target code generators</span></a>
construct a <a class="reference internal" href="runtime.html#tvm-runtime-system-module"><span class="std std-ref">Module</span></a> consisting of
one or more <a class="reference internal" href="runtime.html#tvm-runtime-system-packed-func"><span class="std std-ref">PackedFunc</span></a>, from
an IRModule.</p></li>
</ul>
<div class="section" id="deviceapi">
<span id="tvm-target-specific-device-api"></span><h2>DeviceAPI<a class="headerlink" href="#deviceapi" title="永久链接至标题">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">DeviceAPI</span></code> represents a handle to a specific hardware device
API.  (e.g. <code class="docutils literal notranslate"><span class="pre">CUDADeviceAPI</span></code> handles all interactions through the
CUDA framework.)  Most <code class="docutils literal notranslate"><span class="pre">DeviceAPI</span></code> methods accept a <code class="docutils literal notranslate"><span class="pre">device_id</span></code>
parameter to specify which device should be accessed.  In Python,
these are typically accessed using the <code class="xref py py-func docutils literal notranslate"><span class="pre">tvm.runtime.device()</span></code>
function, which returns a handle to a specific device, accessed
through a specific API.  (e.g. <code class="docutils literal notranslate"><span class="pre">tvm.runtime.device('cuda',0)</span></code> gives
access to physical device <code class="docutils literal notranslate"><span class="pre">0</span></code>, accessed through the CUDA API.)</p>
<ul>
<li><p>Attribute queries - <code class="docutils literal notranslate"><span class="pre">GetAttr</span></code> allows different
device-specific parameters to be queried, such as the device name,
number of threads, etc.  The parameters that can be queried are
defined in <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">DeviceAttrKind</span></code> in <a class="reference external" href="https://github.com/apache/tvm/blob/main/include/tvm/runtime/device_api.h">device_api.h</a>.  Not all
query-able parameters are supported by all devices.  If a parameter
cannot be queried (e.g. <code class="docutils literal notranslate"><span class="pre">kMaxClockRate</span></code> on Vulkan), or if a
parameter isn’t applicable (e.g. <code class="docutils literal notranslate"><span class="pre">kWarpSize</span></code> on CPU), then those
queries should return <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p></li>
<li><p>Setting active device - <code class="docutils literal notranslate"><span class="pre">SetDevice</span></code> should set a
particular device as being active.  If a <code class="docutils literal notranslate"><span class="pre">PackedFunc</span></code> generated by
the target-specific code gen requires execution on a device, it
should run on the active device.</p></li>
<li><p>Memory management - Utilities for allocating and deallocating memory
on the device.</p>
<ul>
<li><p>Allocate data space - <code class="docutils literal notranslate"><span class="pre">AllocDataSpace</span></code> and <code class="docutils literal notranslate"><span class="pre">FreeDataSpace</span></code>
allocate and free space on the device.  These allocations can be
provided as inputs and outputs to an operator and make up the
primary data flow of the operator graph.  It must be possible to
transfer data from the host to/from a data space.  The return
value is an opaque <code class="docutils literal notranslate"><span class="pre">void*</span></code>.  While some implementations return a
memory address, this is not required, and the <code class="docutils literal notranslate"><span class="pre">void*</span></code> may be an
opaque handle that is interpretable only by the device backend
that generated it.  The <code class="docutils literal notranslate"><span class="pre">void*</span></code> is used as an argument to other
backend-specific functions, such as <code class="docutils literal notranslate"><span class="pre">CopyDataFromTo</span></code>.</p></li>
<li><p>Allocate work space - <code class="docutils literal notranslate"><span class="pre">AllocWorkspace</span></code> and <code class="docutils literal notranslate"><span class="pre">FreeWorkspace</span></code>
allocate and free space on the device.  Unlike data space, these
are used for storage of intermediate values within an operator
definition, and are not required to be transferable to/from the
host device.  If a <code class="docutils literal notranslate"><span class="pre">DeviceAPI</span></code> subclass does not implement these
methods, they will default to calling the corresponding
<code class="docutils literal notranslate"><span class="pre">DataSpace</span></code> functions.</p></li>
<li><p>Copy data - <code class="docutils literal notranslate"><span class="pre">CopyDataFromTo</span></code> should copy data from one location
to another.  The type of copy is determined by the <code class="docutils literal notranslate"><span class="pre">dev_from</span></code>
and <code class="docutils literal notranslate"><span class="pre">dev_to</span></code> parameters.  Implementations should support copying
memory from CPU to device, from device to CPU, and from one buffer
to another on a single device.  If the source or destination
locations are on the CPU, the corresponding <code class="docutils literal notranslate"><span class="pre">void*</span></code> points to a
CPU address that can be passed into <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>.  If the source or
destinations locations are on the device, the corresponding
<code class="docutils literal notranslate"><span class="pre">void*</span></code> was previously generated by either <code class="docutils literal notranslate"><span class="pre">AllocDataSpace</span></code> or
<code class="docutils literal notranslate"><span class="pre">AllocWorkspace</span></code>.</p>
<p>These copies are queued to execute on a specific
<code class="docutils literal notranslate"><span class="pre">TVMStreamHandle</span></code>.  However, implementations should not assume
that CPU buffers remains valid or accessible after the call to
<code class="docutils literal notranslate"><span class="pre">CopyDataFromTo</span></code> completes.</p>
</li>
</ul>
</li>
<li><p>Execution stream management - Utilities for handling
<code class="docutils literal notranslate"><span class="pre">TVMStreamHandle</span></code>, which represents parallel streams of execution
used to execute commands.</p>
<ul class="simple">
<li><p>Create stream - <code class="docutils literal notranslate"><span class="pre">CreateStream</span></code> and <code class="docutils literal notranslate"><span class="pre">FreeStream</span></code> should
allocate/free a handle to a stream of execution. If a device
implements only a single queue of commands, then <code class="docutils literal notranslate"><span class="pre">CreateStream</span></code>
should return <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p></li>
<li><p>Set active stream - <code class="docutils literal notranslate"><span class="pre">SetStream</span></code> should set a stream as being
active.  While active, if a <code class="docutils literal notranslate"><span class="pre">PackedFunc</span></code> generated by the
target-specific code gen requires execution on a device, the work
should be submitted to the active stream.</p></li>
<li><p>Synchronize to CPU - <code class="docutils literal notranslate"><span class="pre">StreamSync</span></code> should synchronize a stream of
execution to the CPU.  The call to <code class="docutils literal notranslate"><span class="pre">StreamSync</span></code> should return
once all memory transfers and computations submitted prior to the
<code class="docutils literal notranslate"><span class="pre">StreamSync</span></code> call have completed.</p></li>
<li><p>Synchronize between streams - <code class="docutils literal notranslate"><span class="pre">SyncStreamFromTo</span></code> should
introduce a synchronization barrier between the source and
destination stream.  That is, the destination stream may not
proceed beyond commands currently queued until the source stream
has completed all commands that are currently queued.</p></li>
</ul>
</li>
</ul>
<p>In order to be usable by the TVM framework, the new DeviceAPI should
then be registered with the following steps.</p>
<ol class="arabic">
<li><p>Create a function that instantiates the new DeviceAPI, and returns
a pointer to it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FooDeviceAPI</span><span class="o">*</span> <span class="n">FooDeviceAPI</span><span class="p">::</span><span class="n">Global</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">static</span> <span class="n">FooDeviceAPI</span> <span class="n">inst</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">inst</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Register the function to the tvm registry:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TVM_REGISTER_GLOBAL</span><span class="p">(</span><span class="s2">&quot;device_api.foo&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_body_typed</span><span class="p">(</span><span class="n">FooDeviceAPI</span><span class="p">::</span><span class="n">Global</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ol>
<ol class="arabic simple">
<li><p>Add an entry for the new DeviceAPI to the <code class="docutils literal notranslate"><span class="pre">TVMDeviceExtType</span></code> enum
in <a class="reference external" href="https://github.com/apache/tvm/blob/main/include/tvm/runtime/c_runtime_api.h">c_runtime_api.h</a>.  The value should be an unused value greater
than <code class="docutils literal notranslate"><span class="pre">DLDeviceType::kDLExtDev</span></code>, but less than
<code class="docutils literal notranslate"><span class="pre">DeviceAPIManager::kMaxDeviceAPI</span></code>.</p></li>
<li><p>Add a case in <code class="docutils literal notranslate"><span class="pre">DeviceName</span></code> in <a class="reference external" href="https://github.com/apache/tvm/blob/main/include/tvm/runtime/device_api.h">device_api.h</a> to convert from the
enum value to a string representation.  This string representation
should match the name given to <code class="docutils literal notranslate"><span class="pre">TVM_REGISTER_GLOBAL</span></code>.</p></li>
<li><p>Add entries to the <code class="docutils literal notranslate"><span class="pre">MASK2STR</span></code> and <code class="docutils literal notranslate"><span class="pre">STR2MASK</span></code> dictionaries of
<code class="xref py py-class docutils literal notranslate"><span class="pre">tvm.runtime.Device</span></code> for the new enum value.</p></li>
</ol>
</div>
<div class="section" id="target-definition">
<span id="tvm-target-specific-target"></span><h2>Target Definition<a class="headerlink" href="#target-definition" title="永久链接至标题">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Target</span></code> object is a lookup table of properties about a physical
device, its hardware/driver limits, and its capabilities.  The
<code class="docutils literal notranslate"><span class="pre">Target</span></code> is accessible both during optimization and code generation
stages.  While the same <code class="docutils literal notranslate"><span class="pre">Target</span></code> class is used for all runtime
targets, each runtime target may need to add target-specific options.</p>
<p>In <a class="reference external" href="https://github.com/apache/tvm/blob/main/src/target/target_kind.cc">target_kind.cc</a>, add a new declaration of
<code class="docutils literal notranslate"><span class="pre">TVM_REGISTER_TARGET_KIND</span></code>, passing a string name of the new target,
and the <code class="docutils literal notranslate"><span class="pre">TVMDeviceExtType</span></code> or <code class="docutils literal notranslate"><span class="pre">DLDeviceType</span></code> enum value for the
device on which that target should run.  Typically, the target name
and the device name will match.  (e.g. The <code class="docutils literal notranslate"><span class="pre">&quot;cuda&quot;</span></code> target runs on
the <code class="docutils literal notranslate"><span class="pre">kDLCUDA</span></code> device.)  There are exceptions, such as when multiple
different code generation targets can run on the same physical device.
(e.g. The <code class="docutils literal notranslate"><span class="pre">&quot;llvm&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;c&quot;</span></code> targets both run on the <code class="docutils literal notranslate"><span class="pre">kDLCPU</span></code>
device type.)</p>
<p>All options for a specific target kind are added with the
<code class="docutils literal notranslate"><span class="pre">add_attr_option</span></code> function, with optional default values.  A
preprocessor can be added with <code class="docutils literal notranslate"><span class="pre">set_attrs_preprocessor</span></code> to define
any parameters that are dynamically based on other parameters or
queried from device properties.</p>
<p>This argument definition defines a parser that can unpack a string
description of a target.  This is done in the <code class="docutils literal notranslate"><span class="pre">Target::Target(const</span>
<span class="pre">String&amp;)</span></code> constructor in C++, which accepts a JSON-formatted string
and is typically called using the <code class="xref py py-class docutils literal notranslate"><span class="pre">tvm.target.Target</span></code> python
object.  For example, <code class="docutils literal notranslate"><span class="pre">tvm.target.Target('{&quot;kind&quot;:</span> <span class="pre">&quot;cuda&quot;,</span>
<span class="pre">&quot;max_num_threads&quot;:</span> <span class="pre">1024}')</span></code> will create a <code class="docutils literal notranslate"><span class="pre">cuda</span></code> target, while
overriding the default maximum number of threads.</p>
<p>In a code generator, the target properties can be accessed using
<code class="docutils literal notranslate"><span class="pre">target-&gt;GetAttr&lt;T&gt;(param_name)</span></code> in C++, or with the
<code class="docutils literal notranslate"><span class="pre">target.attrs</span></code> dictionary in Python.</p>
</div>
<div class="section" id="target-code-generators">
<span id="tvm-target-specific-codegen"></span><h2>Target Code Generators<a class="headerlink" href="#target-code-generators" title="永久链接至标题">¶</a></h2>
<p>The code generators take an optimized <code class="docutils literal notranslate"><span class="pre">IRModule</span></code> and converts it
into an executable representation.  Each code generator must be
registered in order to be used by the TVM framework.  This is done by
registering a function named <code class="docutils literal notranslate"><span class="pre">&quot;target.build.foo&quot;</span></code>, where <code class="docutils literal notranslate"><span class="pre">foo</span></code> is
the same name as was used in the <code class="docutils literal notranslate"><span class="pre">TVM_REGISTER_TARGET_KIND</span></code>
definition above.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tvm</span><span class="p">::</span><span class="n">runtime</span><span class="p">::</span><span class="n">Module</span> <span class="n">GeneratorFooCode</span><span class="p">(</span><span class="n">IRModule</span> <span class="n">mod</span><span class="p">,</span> <span class="n">Target</span> <span class="n">target</span><span class="p">);</span>
<span class="n">TVM_REGISTER_GLOBAL</span><span class="p">(</span><span class="s2">&quot;target.build.foo&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_body_typed</span><span class="p">(</span><span class="n">GeneratorFooCode</span><span class="p">);</span>
</pre></div>
</div>
<p>The code generator takes two arguments.  The first is the <code class="docutils literal notranslate"><span class="pre">IRModule</span></code>
to compile, and the second is the <code class="docutils literal notranslate"><span class="pre">Target</span></code> that describes the device
on which the code should run.  Because the environment performing the
compilation is not necessarily the same as the environment that will
be executing the code, code generators should not perform any
attribute lookups on the device itself, and should instead access
parameters stored in the <code class="docutils literal notranslate"><span class="pre">Target</span></code>.</p>
<p>Each function in the input <code class="docutils literal notranslate"><span class="pre">IRModule</span></code> should be accessible by name
in the output <code class="docutils literal notranslate"><span class="pre">runtime::Module</span></code>.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">tvm-cn</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">Installing TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contributor Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../how_to/index.html">How To Guides</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev/tutorial/index.html">Developer Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/how_to/how_to.html">Developer How-To Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Architecture Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Design and Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Topic Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topic/microtvm/index.html">microTVM: TVM on bare-metal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic/vta/index.html">VTA: Versatile Tensor Accelerator</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Design and Architecture</a><ul>
      <li>Previous: <a href="introduction_to_module_serialization.html" title="上一章">Introduction to Module Serialization</a></li>
      <li>Next: <a href="pass_infra.html" title="下一章">Pass Infrastructure</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, HyperAI.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/arch/device_target_interactions.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>